#!/usr/bin/env perl

use strict;
use warnings;
use autodie;

use File::Spec::Functions;
use Scalar::Util qw(looks_like_number);

my $genome_seq = q{};
my $sepal_set  = q{};
my $fimo_list  = q{};

$genome_seq = $ARGV[0] or die "Format: get_fimo_hit_rates_08mar2016.pl *[genome seq. file]* [sepal all-genes list] [fimo list file]\n";
$sepal_set  = $ARGV[1] or die "Format: get_fimo_hit_rates_08mar2016.pl [genome seq. file] *[sepal all-genes list]* [fimo list file]\n";
$fimo_list  = $ARGV[2] or die "Format: get_fimo_hit_rates_08mar2016.pl [genome seq. file] [sepal all-genes list] *[fimo list file]*\n";

my $data_ref;

my $motif = q{};

my $header = "Data\t"
             . "Motif\t"
             . "Orig_search_genes\t"
             . "Orig_positive_genes\t"
             . "Redisc_positive_genes\t"
             . "All_genes\t"
             . "All_sepal_genes\t"
             . "Genomewide_hits\t"
             . "Sepalwide_hits\t"
             . "Redisc_orig_query_ratio\t"
             . "Redisc_orig_pos_ratio\t"
             . "Gwide_hit_ratio\t"
             . "Sepalwide_hit_ratio\t"
             . "Query_enrichment\t"
             . "Sepal_enrichment"
             ;

open my $GEN, '<', $genome_seq;
while (my $input = <$GEN>) {
    # Note that this maps contig names like 'AT1G38630_2' to gene names like 'AT1G38630'.
    # For our purposes that is appropriate; we don't care if a gene got hit 2+ times in 2+ contigs; only if it was hit at all.
    if ( $input =~ /\A [>] (AT (?: 1|2|3|4|5|C|M) G\d+) /xms ) {
        my $seq = $1;
        $data_ref->{'genseq'}->{$seq} = 1;
    }
    elsif ( $input =~ /\A [>] /xms ) { 
        die "Cannot parse header in genome seq. $genome_seq: $input\n";
    }
}
close $GEN;

open my $SEPAL, '<', $sepal_set;
while (my $input = <$SEPAL>) {
    # Record genes only, not contig suffixes.
    if ( $input =~ /\A (AT (?: 1|2|3|4|5|C|M) G\d+) /xms ) {
        my $seq = $1;
        $data_ref->{'sepal_gene'}->{$seq} = 1;
    }
    else {
        die "Cannot parse text in sepal gene list $sepal_set: $input\n";
    }
}
close $SEPAL;

open my $LIST, '<', $fimo_list;
while (my $fimo_file = <$LIST> ) {
    chomp $fimo_file;
    if (! -r $fimo_file) {
        die "Cannot read putative FIMO input file: $fimo_file\n";
    }

    if ( $fimo_file =~ /\A \/mnt\/home\/emsch\/work\/2015\/adrienne\/ncDNA_motifs\/ ([^\/\s]+) \/ ( [^\/\s]+ \/ fimo\.txt ) \z /xms ) {
        my $data_type = $1;
        my $fimo_stem = $2;

        my $meme_stem = $fimo_stem;
        $meme_stem =~ s/fimo/meme/g;
        my $meme_file = catfile('/mnt/home/emsch/work/2015/adrienne/ncDNA_motifs', $data_type, $meme_stem);

        if (! -r $meme_file ) {
            die "Cannot read putative MEME input file: $meme_file\n";
        }

        my $seq_file = $data_type . '_500trans_dna.fa';
        $seq_file    = catfile('/mnt/home/emsch/work/2015/adrienne/ncDNA_motifs', $data_type, $seq_file);
        if (! -r $seq_file ) {
            die "Cannot read putative sequence input file: $seq_file\n";
        }

        open my $INSEQ, '<', $seq_file;
        while (my $input = <$INSEQ>) {
            chomp $input;
            # Record gene names but not contig suffixes.
            if ( $input =~ /\A [>] (AT (?: 1|2|3|4|5|C|M) G\d+) /xms ) {
                my $gene = $1;
                if (! exists $data_ref->{'genseq'}->{$gene} ) {
                    die "From data-type sequence input file $seq_file, cannot recognize gene \"$gene\" in: $input\n";
                }                
                # Note that this applies for *all* motifs generated by the 'data_type' search, so we do not specify a motif!
                $data_ref->{'data_type'}->{$data_type}->{'orig_seq_set'}->{$gene} = 1;
            }
            elsif ( $input =~ /\A [>] /xms ) { 
                die "From data-type sequence input file $seq_file, cannot parse header: $input\n";
            }
        }
        close $INSEQ;

        open my $FIMO, '<', $fimo_file;
        $motif = q{};
        while (my $input = <$FIMO>) {
            chomp $input;
            # Once again, we take up gene names but do not distinguish contig names (if they happen to be there).
            # Sample input:
            # 3	AT1G38630_2	2	13	-	15.6279	4.03e-06	0.0153	AAGAAAAAGGAG
            if ( $input =~ /\A (\S+) \t (AT (?: 1|2|3|4|5|C|M) G\d+) [^\t]* \t (?: [^\t]* \t){4} (\S+) \t /xms ) {
                $motif      = $1;
                my $gene    = $2;
                my $p_value = $3;

                if (! exists $data_ref->{'genseq'}->{$gene} ) {
                    die "From FIMO file $fimo_file, cannot recognize gene \"$gene\" in: $input\n";
                }
                if (! looks_like_number($p_value) ) {
                    die "From FIMO file $fimo_file, non-numerical p-value \"$p_value\" in: $input\n";
                }

                if ( $p_value <= 1e-05 ) {
                    $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif}->{'genomewide'}->{$gene} = 1;
                }
            }
            elsif ( $input !~ /\A [#] pattern [ ] name /xms ) { 
                die "From FIMO file $fimo_file, cannot parse: $input\n";
            }
        }
        close $FIMO;

        open my $MEME, '<', $meme_file;
        # We use $motif in two ways; first, obviously, for its identity; but also, as a flag to tell us when to count gene hits!
        $motif = q{};
        while (my $input = <$MEME>) {
            chomp $input;
            if ( $input =~ / Motif [ ] (\S+) [ ] sites [ ] sorted [ ] by [ ] position [ ] p-value /xms ) {
                $motif = $1;
            }
            # Once again, we record gene names but ignore contig suffixes, *if* we have a non-zero $motif.
            elsif ( $motif and ( $input =~ /\A (AT (?: 1|2|3|4|5|C|M) G\d+) [\t]* /xms ) ) {
                my $gene = $1;
                if (! exists $data_ref->{'genseq'}->{$gene} ) {
                    die "From MEME file $meme_file, cannot record a hit for motif $motif in gene $gene\n";
                }
                # We choose to ignore situations for now where no genomewide motifs were discovered.
                else { 
                    $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif}->{'orig_positive'}->{$gene} = 1;
                }
            }
            elsif ( $input =~ / Motif \S+ block diagrams /xms ) { 
                # Zero out the identity and also negate the "read gene hits" flag.
                $motif = q{};
            }
        }
        close $MEME;

        my @motifs = sort keys %{ $data_ref->{'data_type'}->{$data_type}->{'motif'} };
        foreach my $motif_1 (@motifs) {
            my @redisc_orig_pos = ();
            my @orig_positives  = sort keys %{ $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif_1}->{'orig_positive'} };

            foreach my $orig_positive (@orig_positives) {
                if ( exists $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif_1}->{'genomewide'}->{$orig_positive} ) {
                    push @redisc_orig_pos, $orig_positive;
                }
            }

            my @genome_wide_hits = ();
            # Defend ourselves against cases where *zero* motif sites are found genomewide.
            if ( exists $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif_1}->{'genomewide'} ) {
                @genome_wide_hits = sort keys %{ $data_ref->{'data_type'}->{$data_type}->{'motif'}->{$motif_1}->{'genomewide'} };
            }

            # Of the genome-wide hits, how many overlapped in any way with our sepal genes that changed expression genotypically?
            # This is a crude measurement and can miss subtle subsets, but it's also not particularly biased by any specific ideas.
            my @sepal_spec_gwide_hits = grep { ( exists $data_ref->{'sepal_gene'}->{$_} ) } @genome_wide_hits;

            my @total_genes      = sort keys %{ $data_ref->{'genseq'} };
            my @sepal_genes      = sort keys %{ $data_ref->{'sepal_gene'} };
            my @orig_genes       = sort keys %{ $data_ref->{'data_type'}->{$data_type}->{'orig_seq_set'} };

            my $redisc_pos_count = @redisc_orig_pos;
            my $orig_pos_count   = @orig_positives;
            my $orig_gene_count  = @orig_genes;

            my $genomewide_count  = @genome_wide_hits;
            my $sepalwide_count   = @sepal_spec_gwide_hits;
            my $total_gene_count  = @total_genes;
            my $total_sepal_count = @sepal_genes;

            my $pos_repr_ratio   = 0;
            if ( $orig_pos_count > 0 ) {
                $pos_repr_ratio = ($redisc_pos_count / $orig_pos_count);
            }

            my $redisc_ratio = 0;
            if ( $orig_gene_count > 0 ) { 
                $redisc_ratio = ($redisc_pos_count / $orig_gene_count);
            }
            else { 
                die "For data set $data_type, putatively zero original genes!\n";
            }

            my $genomewide_ratio = ($genomewide_count / $total_gene_count);
            my $sepalwide_ratio  = ($sepalwide_count  / $total_sepal_count);

            my $query_enrichment  = 0;
            my $sepal_enrichment  = 0;
            if ( $genomewide_ratio > 0 ) {
                $query_enrichment = ($redisc_ratio / $genomewide_ratio);
                $sepal_enrichment = ($sepalwide_ratio / $genomewide_ratio);
            }

            # As a possibly useful side product, print list of genomewide hits for each motif.
            # This can be given a fast check with AgriGO, and followed up if it looks promising.
            my $gwide_motif_hits = "$data_type.motif.$motif_1.genomewide_hits.txt";
            $gwide_motif_hits = safename($gwide_motif_hits);
            open my $MOT_HITS, '>', $gwide_motif_hits;
            foreach my $gwide_hit (@genome_wide_hits) {
                print $MOT_HITS "$gwide_hit\n";
            }
            close $MOT_HITS;

            # format at last possible step:
            my $print_orig_pos_count   = commify($orig_pos_count);
            my $print_redisc_pos_count = commify($redisc_pos_count);
            my $print_orig_gene_count  = commify($orig_gene_count);

            my $print_genomewide_count = commify($genomewide_count);
            my $print_sepalwide_count  = commify($sepalwide_count);
            my $print_total_gene_count = commify($total_gene_count);
            my $print_tot_sep_g_count  = commify($total_sepal_count);

            my $print_pos_repr_ratio = sprintf "%.2f", $pos_repr_ratio;
            my $print_redisc_ratio   = sprintf "%.2f", $redisc_ratio;
            my $print_gwide_ratio    = sprintf "%.4f", $genomewide_ratio;
            my $print_swide_ratio    = sprintf "%.4f", $sepalwide_ratio;
            my $print_q_enrichment   = sprintf "%.2f", $query_enrichment;
            my $print_s_enrichment   = sprintf "%.2f", $sepal_enrichment;

            print "$header\n" if $header;
            $header = q{};

            print "$data_type\t";
            print "$motif_1\t";
            print "$print_orig_gene_count\t"; 
            print "$print_orig_pos_count\t";
            print "$print_redisc_pos_count\t";
            print "$print_total_gene_count\t";
            print "$print_tot_sep_g_count\t";
            print "$print_genomewide_count\t";
            print "$print_sepalwide_count\t";
            print "$print_redisc_ratio\t";
            print "$print_pos_repr_ratio\t";
            print "$print_gwide_ratio\t";
            print "$print_swide_ratio\t";
            print "$print_q_enrichment\t";
            print "$print_s_enrichment";
            print "\n";
        }
    }
    else { 
        die "Cannot parse input: $fimo_file\n";
    }    
}
close $LIST;


# Source -- Perl Cookbook 2.16, p. 84:
sub commify { 
    my $_text = reverse $_[0];
    $_text =~ s/ (\d{3}) 
                 (?=\d) 
                 (?!\d*\.)
               /$1,/xmsg;
    return scalar reverse $_text;
}

sub safename {
    my $filename = $_[0];
    my $orig_filename = $filename;
    if (-e $orig_filename) {
        my $suffix1 = 1;
        $filename = $filename . ".$suffix1";
        while (-e $filename) {
            $suffix1++;
            $filename =~ s/\.\d+\z//xms;
            $filename = $filename . ".$suffix1";
        }
    }
    return $filename;
}


